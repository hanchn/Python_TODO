# 第七章：功能扩展与最佳实践

## 7.1 用户认证与权限管理

### 用户模型设计
```python
# models/user.py
from werkzeug.security import generate_password_hash, check_password_hash
from flask_login import UserMixin
from datetime import datetime
from config import db

class User(UserMixin, db.Model):
    """用户模型"""
    __tablename__ = 'users'
    
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False, index=True)
    email = db.Column(db.String(120), unique=True, nullable=False, index=True)
    password_hash = db.Column(db.String(255), nullable=False)
    
    # 用户信息
    real_name = db.Column(db.String(100), nullable=False)
    phone = db.Column(db.String(20))
    avatar = db.Column(db.String(255), default='default.jpg')
    
    # 权限和状态
    role = db.Column(db.String(20), default='user')  # admin, teacher, user
    is_active = db.Column(db.Boolean, default=True)
    is_verified = db.Column(db.Boolean, default=False)
    
    # 时间戳
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    last_login = db.Column(db.DateTime)
    
    def set_password(self, password):
        """设置密码"""
        self.password_hash = generate_password_hash(password)
    
    def check_password(self, password):
        """验证密码"""
        return check_password_hash(self.password_hash, password)
    
    def has_permission(self, permission):
        """检查权限"""
        role_permissions = {
            'admin': ['read', 'write', 'delete', 'manage_users'],
            'teacher': ['read', 'write', 'delete'],
            'user': ['read']
        }
        return permission in role_permissions.get(self.role, [])
    
    def is_admin(self):
        """是否为管理员"""
        return self.role == 'admin'
    
    def to_dict(self):
        """转换为字典"""
        return {
            'id': self.id,
            'username': self.username,
            'email': self.email,
            'real_name': self.real_name,
            'phone': self.phone,
            'avatar': self.avatar,
            'role': self.role,
            'is_active': self.is_active,
            'is_verified': self.is_verified,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'last_login': self.last_login.isoformat() if self.last_login else None
        }
    
    def __repr__(self):
        return f'<User {self.username}>'

# 角色权限映射
class Permission:
    """权限常量"""
    READ = 'read'
    WRITE = 'write'
    DELETE = 'delete'
    MANAGE_USERS = 'manage_users'
    
    @staticmethod
    def get_role_permissions(role):
        """获取角色权限"""
        permissions = {
            'admin': [Permission.READ, Permission.WRITE, Permission.DELETE, Permission.MANAGE_USERS],
            'teacher': [Permission.READ, Permission.WRITE, Permission.DELETE],
            'user': [Permission.READ]
        }
        return permissions.get(role, [])
```

### 认证系统实现
```python
# auth/__init__.py
from flask import Blueprint
from flask_login import LoginManager

auth_bp = Blueprint('auth', __name__, url_prefix='/auth')
login_manager = LoginManager()

def init_auth(app):
    """初始化认证系统"""
    login_manager.init_app(app)
    login_manager.login_view = 'auth.login'
    login_manager.login_message = '请先登录访问此页面'
    login_manager.login_message_category = 'info'
    
    @login_manager.user_loader
    def load_user(user_id):
        from models.user import User
        return User.query.get(int(user_id))
    
    app.register_blueprint(auth_bp)

from . import routes
```

```python
# auth/routes.py
from flask import render_template, request, flash, redirect, url_for, jsonify
from flask_login import login_user, logout_user, login_required, current_user
from datetime import datetime
from . import auth_bp
from models.user import User
from config import db
from .forms import LoginForm, RegisterForm, ChangePasswordForm

@auth_bp.route('/login', methods=['GET', 'POST'])
def login():
    """用户登录"""
    if current_user.is_authenticated:
        return redirect(url_for('student.index'))
    
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        
        if user and user.check_password(form.password.data):
            if not user.is_active:
                flash('账户已被禁用，请联系管理员', 'error')
                return render_template('auth/login.html', form=form)
            
            # 更新最后登录时间
            user.last_login = datetime.utcnow()
            db.session.commit()
            
            login_user(user, remember=form.remember_me.data)
            
            # 重定向到原页面或首页
            next_page = request.args.get('next')
            if not next_page or not next_page.startswith('/'):
                next_page = url_for('student.index')
            
            flash(f'欢迎回来，{user.real_name}！', 'success')
            return redirect(next_page)
        else:
            flash('用户名或密码错误', 'error')
    
    return render_template('auth/login.html', form=form)

@auth_bp.route('/register', methods=['GET', 'POST'])
def register():
    """用户注册"""
    if current_user.is_authenticated:
        return redirect(url_for('student.index'))
    
    form = RegisterForm()
    if form.validate_on_submit():
        # 检查用户名和邮箱是否已存在
        if User.query.filter_by(username=form.username.data).first():
            flash('用户名已存在', 'error')
            return render_template('auth/register.html', form=form)
        
        if User.query.filter_by(email=form.email.data).first():
            flash('邮箱已被注册', 'error')
            return render_template('auth/register.html', form=form)
        
        # 创建新用户
        user = User(
            username=form.username.data,
            email=form.email.data,
            real_name=form.real_name.data,
            phone=form.phone.data,
            role='user'  # 默认角色
        )
        user.set_password(form.password.data)
        
        db.session.add(user)
        db.session.commit()
        
        flash('注册成功，请登录', 'success')
        return redirect(url_for('auth.login'))
    
    return render_template('auth/register.html', form=form)

@auth_bp.route('/logout')
@login_required
def logout():
    """用户登出"""
    logout_user()
    flash('您已成功登出', 'info')
    return redirect(url_for('auth.login'))

@auth_bp.route('/profile')
@login_required
def profile():
    """用户资料"""
    return render_template('auth/profile.html', user=current_user)

@auth_bp.route('/change-password', methods=['GET', 'POST'])
@login_required
def change_password():
    """修改密码"""
    form = ChangePasswordForm()
    if form.validate_on_submit():
        if not current_user.check_password(form.old_password.data):
            flash('原密码错误', 'error')
            return render_template('auth/change_password.html', form=form)
        
        current_user.set_password(form.new_password.data)
        db.session.commit()
        
        flash('密码修改成功', 'success')
        return redirect(url_for('auth.profile'))
    
    return render_template('auth/change_password.html', form=form)
```

### 权限装饰器
```python
# auth/decorators.py
from functools import wraps
from flask import abort, flash, redirect, url_for
from flask_login import current_user

def permission_required(permission):
    """权限检查装饰器"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not current_user.is_authenticated:
                flash('请先登录', 'warning')
                return redirect(url_for('auth.login'))
            
            if not current_user.has_permission(permission):
                abort(403)
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator

def admin_required(f):
    """管理员权限装饰器"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            flash('请先登录', 'warning')
            return redirect(url_for('auth.login'))
        
        if not current_user.is_admin():
            abort(403)
        
        return f(*args, **kwargs)
    return decorated_function

def role_required(role):
    """角色检查装饰器"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if not current_user.is_authenticated:
                flash('请先登录', 'warning')
                return redirect(url_for('auth.login'))
            
            if current_user.role != role:
                abort(403)
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator
```

### 表单定义
```python
# auth/forms.py
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, BooleanField, SubmitField
from wtforms.validators import DataRequired, Length, Email, EqualTo, Regexp

class LoginForm(FlaskForm):
    """登录表单"""
    username = StringField('用户名', validators=[
        DataRequired(message='用户名不能为空'),
        Length(min=3, max=20, message='用户名长度应在3-20个字符之间')
    ])
    password = PasswordField('密码', validators=[
        DataRequired(message='密码不能为空')
    ])
    remember_me = BooleanField('记住我')
    submit = SubmitField('登录')

class RegisterForm(FlaskForm):
    """注册表单"""
    username = StringField('用户名', validators=[
        DataRequired(message='用户名不能为空'),
        Length(min=3, max=20, message='用户名长度应在3-20个字符之间'),
        Regexp(r'^[a-zA-Z0-9_]+$', message='用户名只能包含字母、数字和下划线')
    ])
    email = StringField('邮箱', validators=[
        DataRequired(message='邮箱不能为空'),
        Email(message='邮箱格式不正确')
    ])
    real_name = StringField('真实姓名', validators=[
        DataRequired(message='真实姓名不能为空'),
        Length(min=2, max=20, message='姓名长度应在2-20个字符之间')
    ])
    phone = StringField('手机号', validators=[
        Regexp(r'^1[3-9]\d{9}$', message='手机号格式不正确')
    ])
    password = PasswordField('密码', validators=[
        DataRequired(message='密码不能为空'),
        Length(min=6, max=20, message='密码长度应在6-20个字符之间')
    ])
    password2 = PasswordField('确认密码', validators=[
        DataRequired(message='请确认密码'),
        EqualTo('password', message='两次输入的密码不一致')
    ])
    submit = SubmitField('注册')

class ChangePasswordForm(FlaskForm):
    """修改密码表单"""
    old_password = PasswordField('原密码', validators=[
        DataRequired(message='原密码不能为空')
    ])
    new_password = PasswordField('新密码', validators=[
        DataRequired(message='新密码不能为空'),
        Length(min=6, max=20, message='密码长度应在6-20个字符之间')
    ])
    new_password2 = PasswordField('确认新密码', validators=[
        DataRequired(message='请确认新密码'),
        EqualTo('new_password', message='两次输入的密码不一致')
    ])
    submit = SubmitField('修改密码')
```

## 7.2 文件上传与处理

### 文件上传配置
```python
# config.py 添加文件上传配置
import os

class Config:
    # 文件上传配置
    UPLOAD_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
    MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16MB
    ALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif', 'xlsx', 'xls', 'csv'}
    
    # 头像上传配置
    AVATAR_FOLDER = os.path.join(UPLOAD_FOLDER, 'avatars')
    AVATAR_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}
    AVATAR_MAX_SIZE = 2 * 1024 * 1024  # 2MB
    
    # 学生照片配置
    STUDENT_PHOTO_FOLDER = os.path.join(UPLOAD_FOLDER, 'student_photos')
    
    # 文档上传配置
    DOCUMENT_FOLDER = os.path.join(UPLOAD_FOLDER, 'documents')
```

### 文件处理工具
```python
# utils/file_handler.py
import os
import uuid
from PIL import Image
from werkzeug.utils import secure_filename
from flask import current_app, flash

class FileHandler:
    """文件处理工具类"""
    
    @staticmethod
    def allowed_file(filename, allowed_extensions=None):
        """检查文件扩展名是否允许"""
        if allowed_extensions is None:
            allowed_extensions = current_app.config['ALLOWED_EXTENSIONS']
        
        return '.' in filename and \
               filename.rsplit('.', 1)[1].lower() in allowed_extensions
    
    @staticmethod
    def generate_filename(original_filename):
        """生成唯一文件名"""
        ext = original_filename.rsplit('.', 1)[1].lower()
        return f"{uuid.uuid4().hex}.{ext}"
    
    @staticmethod
    def save_file(file, upload_folder, allowed_extensions=None, max_size=None):
        """保存上传的文件"""
        if not file or file.filename == '':
            return None, '请选择文件'
        
        if not FileHandler.allowed_file(file.filename, allowed_extensions):
            return None, '文件类型不支持'
        
        # 检查文件大小
        if max_size:
            file.seek(0, 2)  # 移动到文件末尾
            file_size = file.tell()
            file.seek(0)  # 重置到文件开头
            
            if file_size > max_size:
                return None, f'文件大小不能超过{max_size // (1024*1024)}MB'
        
        # 确保上传目录存在
        os.makedirs(upload_folder, exist_ok=True)
        
        # 生成安全的文件名
        filename = FileHandler.generate_filename(file.filename)
        file_path = os.path.join(upload_folder, filename)
        
        try:
            file.save(file_path)
            return filename, None
        except Exception as e:
            return None, f'文件保存失败：{str(e)}'
    
    @staticmethod
    def resize_image(image_path, max_width=800, max_height=600, quality=85):
        """调整图片大小"""
        try:
            with Image.open(image_path) as img:
                # 转换为RGB模式（如果是RGBA）
                if img.mode in ('RGBA', 'LA', 'P'):
                    img = img.convert('RGB')
                
                # 计算新尺寸
                width, height = img.size
                ratio = min(max_width / width, max_height / height)
                
                if ratio < 1:
                    new_width = int(width * ratio)
                    new_height = int(height * ratio)
                    img = img.resize((new_width, new_height), Image.Resampling.LANCZOS)
                
                # 保存优化后的图片
                img.save(image_path, 'JPEG', quality=quality, optimize=True)
                return True
        except Exception as e:
            print(f"图片处理失败：{e}")
            return False
    
    @staticmethod
    def delete_file(file_path):
        """删除文件"""
        try:
            if os.path.exists(file_path):
                os.remove(file_path)
                return True
        except Exception as e:
            print(f"文件删除失败：{e}")
        return False
    
    @staticmethod
    def get_file_info(file_path):
        """获取文件信息"""
        if not os.path.exists(file_path):
            return None
        
        stat = os.stat(file_path)
        return {
            'size': stat.st_size,
            'created': stat.st_ctime,
            'modified': stat.st_mtime,
            'extension': os.path.splitext(file_path)[1].lower()
        }
```

### 头像上传功能
```python
# controllers/upload_controller.py
from flask import Blueprint, request, jsonify, current_app, url_for
from flask_login import login_required, current_user
from werkzeug.utils import secure_filename
import os
from utils.file_handler import FileHandler
from config import db

upload_bp = Blueprint('upload', __name__, url_prefix='/upload')

@upload_bp.route('/avatar', methods=['POST'])
@login_required
def upload_avatar():
    """上传用户头像"""
    if 'avatar' not in request.files:
        return jsonify({'success': False, 'message': '请选择头像文件'}), 400
    
    file = request.files['avatar']
    
    # 保存文件
    filename, error = FileHandler.save_file(
        file,
        current_app.config['AVATAR_FOLDER'],
        current_app.config['AVATAR_EXTENSIONS'],
        current_app.config['AVATAR_MAX_SIZE']
    )
    
    if error:
        return jsonify({'success': False, 'message': error}), 400
    
    # 处理图片
    file_path = os.path.join(current_app.config['AVATAR_FOLDER'], filename)
    if not FileHandler.resize_image(file_path, max_width=200, max_height=200):
        FileHandler.delete_file(file_path)
        return jsonify({'success': False, 'message': '图片处理失败'}), 500
    
    # 删除旧头像
    if current_user.avatar and current_user.avatar != 'default.jpg':
        old_avatar_path = os.path.join(current_app.config['AVATAR_FOLDER'], current_user.avatar)
        FileHandler.delete_file(old_avatar_path)
    
    # 更新用户头像
    current_user.avatar = filename
    db.session.commit()
    
    return jsonify({
        'success': True,
        'message': '头像上传成功',
        'avatar_url': url_for('static', filename=f'uploads/avatars/{filename}')
    })

@upload_bp.route('/student-photo/<int:student_id>', methods=['POST'])
@login_required
def upload_student_photo(student_id):
    """上传学生照片"""
    from models.student import Student
    
    student = Student.query.get_or_404(student_id)
    
    if 'photo' not in request.files:
        return jsonify({'success': False, 'message': '请选择照片文件'}), 400
    
    file = request.files['photo']
    
    # 保存文件
    filename, error = FileHandler.save_file(
        file,
        current_app.config['STUDENT_PHOTO_FOLDER'],
        current_app.config['AVATAR_EXTENSIONS'],
        current_app.config['AVATAR_MAX_SIZE']
    )
    
    if error:
        return jsonify({'success': False, 'message': error}), 400
    
    # 处理图片
    file_path = os.path.join(current_app.config['STUDENT_PHOTO_FOLDER'], filename)
    if not FileHandler.resize_image(file_path, max_width=300, max_height=400):
        FileHandler.delete_file(file_path)
        return jsonify({'success': False, 'message': '图片处理失败'}), 500
    
    # 删除旧照片
    if student.photo:
        old_photo_path = os.path.join(current_app.config['STUDENT_PHOTO_FOLDER'], student.photo)
        FileHandler.delete_file(old_photo_path)
    
    # 更新学生照片
    student.photo = filename
    db.session.commit()
    
    return jsonify({
        'success': True,
        'message': '照片上传成功',
        'photo_url': url_for('static', filename=f'uploads/student_photos/{filename}')
    })
```

## 7.3 数据导入导出功能

### Excel导入导出
```python
# utils/excel_handler.py
import pandas as pd
from io import BytesIO
from flask import make_response
from datetime import datetime

class ExcelHandler:
    """Excel处理工具类"""
    
    @staticmethod
    def import_students_from_excel(file_path):
        """从Excel导入学生数据"""
        try:
            # 读取Excel文件
            df = pd.read_excel(file_path)
            
            # 验证必需的列
            required_columns = ['学号', '姓名', '性别', '年龄', '专业', '年级']
            missing_columns = [col for col in required_columns if col not in df.columns]
            
            if missing_columns:
                return None, f"缺少必需的列：{', '.join(missing_columns)}"
            
            # 数据清洗和验证
            students_data = []
            errors = []
            
            for index, row in df.iterrows():
                try:
                    # 数据验证
                    student_id = str(row['学号']).strip()
                    name = str(row['姓名']).strip()
                    gender = str(row['性别']).strip()
                    age = int(row['年龄'])
                    major = str(row['专业']).strip()
                    grade = str(row['年级']).strip()
                    
                    # 基本验证
                    if len(student_id) < 6:
                        errors.append(f"第{index+2}行：学号长度不足")
                        continue
                    
                    if not name:
                        errors.append(f"第{index+2}行：姓名不能为空")
                        continue
                    
                    if gender not in ['男', '女']:
                        errors.append(f"第{index+2}行：性别必须是'男'或'女'")
                        continue
                    
                    if age < 16 or age > 30:
                        errors.append(f"第{index+2}行：年龄应在16-30之间")
                        continue
                    
                    student_data = {
                        'student_id': student_id,
                        'name': name,
                        'gender': gender,
                        'age': age,
                        'major': major,
                        'grade': grade,
                        'phone': str(row.get('手机号', '')).strip() or None,
                        'email': str(row.get('邮箱', '')).strip() or None,
                        'address': str(row.get('地址', '')).strip() or None
                    }
                    
                    students_data.append(student_data)
                    
                except Exception as e:
                    errors.append(f"第{index+2}行：数据格式错误 - {str(e)}")
            
            return students_data, errors
            
        except Exception as e:
            return None, f"文件读取失败：{str(e)}"
    
    @staticmethod
    def export_students_to_excel(students):
        """导出学生数据到Excel"""
        try:
            # 准备数据
            data = []
            for student in students:
                data.append({
                    '学号': student.student_id,
                    '姓名': student.name,
                    '性别': student.gender,
                    '年龄': student.age,
                    '专业': student.major,
                    '年级': student.grade,
                    '手机号': student.phone or '',
                    '邮箱': student.email or '',
                    '地址': student.address or '',
                    '创建时间': student.created_at.strftime('%Y-%m-%d %H:%M:%S') if student.created_at else ''
                })
            
            # 创建DataFrame
            df = pd.DataFrame(data)
            
            # 创建Excel文件
            output = BytesIO()
            with pd.ExcelWriter(output, engine='openpyxl') as writer:
                df.to_excel(writer, sheet_name='学生信息', index=False)
                
                # 设置列宽
                worksheet = writer.sheets['学生信息']
                for column in worksheet.columns:
                    max_length = 0
                    column_letter = column[0].column_letter
                    for cell in column:
                        try:
                            if len(str(cell.value)) > max_length:
                                max_length = len(str(cell.value))
                        except:
                            pass
                    adjusted_width = min(max_length + 2, 50)
                    worksheet.column_dimensions[column_letter].width = adjusted_width
            
            output.seek(0)
            return output.getvalue()
            
        except Exception as e:
            raise Exception(f"Excel导出失败：{str(e)}")
    
    @staticmethod
    def create_import_template():
        """创建导入模板"""
        template_data = {
            '学号': ['2024001', '2024002'],
            '姓名': ['张三', '李四'],
            '性别': ['男', '女'],
            '年龄': [20, 19],
            '专业': ['计算机科学', '软件工程'],
            '年级': ['2024级', '2024级'],
            '手机号': ['13800138000', '13900139000'],
            '邮箱': ['zhangsan@example.com', 'lisi@example.com'],
            '地址': ['北京市海淀区', '上海市浦东区']
        }
        
        df = pd.DataFrame(template_data)
        
        output = BytesIO()
        with pd.ExcelWriter(output, engine='openpyxl') as writer:
            df.to_excel(writer, sheet_name='学生信息模板', index=False)
        
        output.seek(0)
        return output.getvalue()
```

### 导入导出控制器
```python
# controllers/import_export_controller.py
from flask import Blueprint, request, jsonify, make_response, render_template, flash, redirect, url_for
from flask_login import login_required
from werkzeug.utils import secure_filename
import os
from datetime import datetime
from models.student import Student
from utils.excel_handler import ExcelHandler
from utils.file_handler import FileHandler
from config import db, app
from auth.decorators import permission_required

import_export_bp = Blueprint('import_export', __name__, url_prefix='/import-export')

@import_export_bp.route('/import', methods=['GET', 'POST'])
@login_required
@permission_required('write')
def import_students():
    """导入学生数据"""
    if request.method == 'GET':
        return render_template('import_export/import.html')
    
    if 'file' not in request.files:
        flash('请选择要导入的文件', 'error')
        return redirect(request.url)
    
    file = request.files['file']
    if file.filename == '':
        flash('请选择要导入的文件', 'error')
        return redirect(request.url)
    
    # 检查文件类型
    if not file.filename.lower().endswith(('.xlsx', '.xls')):
        flash('只支持Excel文件格式', 'error')
        return redirect(request.url)
    
    try:
        # 保存临时文件
        filename = secure_filename(file.filename)
        temp_path = os.path.join(app.config['UPLOAD_FOLDER'], 'temp', filename)
        os.makedirs(os.path.dirname(temp_path), exist_ok=True)
        file.save(temp_path)
        
        # 解析Excel文件
        students_data, errors = ExcelHandler.import_students_from_excel(temp_path)
        
        # 删除临时文件
        os.remove(temp_path)
        
        if students_data is None:
            flash(f'文件解析失败：{errors}', 'error')
            return redirect(request.url)
        
        if errors:
            flash(f'发现{len(errors)}个错误，请检查数据格式', 'warning')
            return render_template('import_export/import.html', errors=errors)
        
        # 检查重复学号
        existing_student_ids = set()
        duplicate_ids = []
        
        for data in students_data:
            student_id = data['student_id']
            if student_id in existing_student_ids:
                duplicate_ids.append(student_id)
            else:
                existing_student_ids.add(student_id)
                
                # 检查数据库中是否已存在
                if Student.query.filter_by(student_id=student_id).first():
                    duplicate_ids.append(student_id)
        
        if duplicate_ids:
            flash(f'发现重复学号：{"、".join(duplicate_ids)}', 'error')
            return redirect(request.url)
        
        # 批量插入数据
        success_count = 0
        for data in students_data:
            try:
                student = Student(**data)
                db.session.add(student)
                success_count += 1
            except Exception as e:
                db.session.rollback()
                flash(f'数据插入失败：{str(e)}', 'error')
                return redirect(request.url)
        
        db.session.commit()
        flash(f'成功导入{success_count}条学生记录', 'success')
        return redirect(url_for('student.index'))
        
    except Exception as e:
        flash(f'导入失败：{str(e)}', 'error')
        return redirect(request.url)

@import_export_bp.route('/export')
@login_required
@permission_required('read')
def export_students():
    """导出学生数据"""
    try:
        # 获取查询参数
        search = request.args.get('search', '')
        grade = request.args.get('grade', '')
        major = request.args.get('major', '')
        
        # 构建查询
        query = Student.query
        
        if search:
            search_filter = f"%{search}%"
            query = query.filter(
                db.or_(
                    Student.name.like(search_filter),
                    Student.student_id.like(search_filter)
                )
            )
        
        if grade:
            query = query.filter(Student.grade == grade)
        
        if major:
            query = query.filter(Student.major == major)
        
        students = query.all()
        
        if not students:
            flash('没有找到符合条件的学生数据', 'warning')
            return redirect(url_for('student.index'))
        
        # 生成Excel文件
        excel_data = ExcelHandler.export_students_to_excel(students)
        
        # 创建响应
        response = make_response(excel_data)
        response.headers['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        response.headers['Content-Disposition'] = f'attachment; filename=学生信息_{datetime.now().strftime("%Y%m%d_%H%M%S")}.xlsx'
        
        return response
        
    except Exception as e:
        flash(f'导出失败：{str(e)}', 'error')
        return redirect(url_for('student.index'))

@import_export_bp.route('/template')
@login_required
def download_template():
    """下载导入模板"""
    try:
        template_data = ExcelHandler.create_import_template()
        
        response = make_response(template_data)
        response.headers['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        response.headers['Content-Disposition'] = 'attachment; filename=学生信息导入模板.xlsx'
        
        return response
        
    except Exception as e:
        flash(f'模板下载失败：{str(e)}', 'error')
        return redirect(url_for('student.index'))

@import_export_bp.route('/api/validate', methods=['POST'])
@login_required
def validate_import_data():
    """验证导入数据"""
    if 'file' not in request.files:
        return jsonify({'success': False, 'message': '请选择文件'})
    
    file = request.files['file']
    
    try:
        # 保存临时文件
        filename = secure_filename(file.filename)
        temp_path = os.path.join(app.config['UPLOAD_FOLDER'], 'temp', filename)
        os.makedirs(os.path.dirname(temp_path), exist_ok=True)
        file.save(temp_path)
        
        # 解析并验证数据
        students_data, errors = ExcelHandler.import_students_from_excel(temp_path)
        
        # 删除临时文件
        os.remove(temp_path)
        
        if students_data is None:
            return jsonify({'success': False, 'message': errors})
        
        return jsonify({
            'success': True,
            'data': {
                'total_count': len(students_data),
                'valid_count': len(students_data) - len(errors),
                'error_count': len(errors),
                'errors': errors[:10]  # 只返回前10个错误
            }
        })
        
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)})
```

## 7.4 系统监控与日志分析

### 系统监控
```python
# utils/monitor.py
import psutil
import time
from datetime import datetime, timedelta
from flask import current_app
from config import db

class SystemMonitor:
    """系统监控工具"""
    
    @staticmethod
    def get_system_info():
        """获取系统信息"""
        try:
            # CPU信息
            cpu_percent = psutil.cpu_percent(interval=1)
            cpu_count = psutil.cpu_count()
            
            # 内存信息
            memory = psutil.virtual_memory()
            memory_percent = memory.percent
            memory_total = memory.total / (1024**3)  # GB
            memory_used = memory.used / (1024**3)  # GB
            
            # 磁盘信息
            disk = psutil.disk_usage('/')
            disk_percent = disk.percent
            disk_total = disk.total / (1024**3)  # GB
            disk_used = disk.used / (1024**3)  # GB
            
            # 网络信息
            network = psutil.net_io_counters()
            
            return {
                'cpu': {
                    'percent': cpu_percent,
                    'count': cpu_count
                },
                'memory': {
                    'percent': memory_percent,
                    'total': round(memory_total, 2),
                    'used': round(memory_used, 2)
                },
                'disk': {
                    'percent': disk_percent,
                    'total': round(disk_total, 2),
                    'used': round(disk_used, 2)
                },
                'network': {
                    'bytes_sent': network.bytes_sent,
                    'bytes_recv': network.bytes_recv
                },
                'timestamp': datetime.now().isoformat()
            }
        except Exception as e:
            current_app.logger.error(f"获取系统信息失败：{e}")
            return None
    
    @staticmethod
    def get_database_stats():
        """获取数据库统计信息"""
        try:
            from models.student import Student
            from models.user import User
            
            stats = {
                'students': {
                    'total': Student.query.count(),
                    'recent': Student.query.filter(
                        Student.created_at >= datetime.now() - timedelta(days=7)
                    ).count()
                },
                'users': {
                    'total': User.query.count(),
                    'active': User.query.filter(User.is_active == True).count()
                }
            }
            
            # 按专业统计学生数量
            major_stats = db.session.query(
                Student.major,
                db.func.count(Student.id).label('count')
            ).group_by(Student.major).all()
            
            stats['students']['by_major'] = {
                major: count for major, count in major_stats
            }
            
            # 按年级统计学生数量
            grade_stats = db.session.query(
                Student.grade,
                db.func.count(Student.id).label('count')
            ).group_by(Student.grade).all()
            
            stats['students']['by_grade'] = {
                grade: count for grade, count in grade_stats
            }
            
            return stats
            
        except Exception as e:
            current_app.logger.error(f"获取数据库统计失败：{e}")
            return None
    
    @staticmethod
    def check_health():
        """健康检查"""
        health_status = {
            'status': 'healthy',
            'checks': {},
            'timestamp': datetime.now().isoformat()
        }
        
        try:
            # 数据库连接检查
            db.session.execute('SELECT 1')
            health_status['checks']['database'] = 'ok'
        except Exception as e:
            health_status['checks']['database'] = f'error: {str(e)}'
            health_status['status'] = 'unhealthy'
        
        try:
            # 系统资源检查
            system_info = SystemMonitor.get_system_info()
            if system_info:
                if system_info['cpu']['percent'] > 90:
                    health_status['checks']['cpu'] = 'warning: high usage'
                    health_status['status'] = 'warning'
                else:
                    health_status['checks']['cpu'] = 'ok'
                
                if system_info['memory']['percent'] > 90:
                    health_status['checks']['memory'] = 'warning: high usage'
                    health_status['status'] = 'warning'
                else:
                    health_status['checks']['memory'] = 'ok'
            else:
                health_status['checks']['system'] = 'error: unable to get info'
                health_status['status'] = 'unhealthy'
        except Exception as e:
            health_status['checks']['system'] = f'error: {str(e)}'
            health_status['status'] = 'unhealthy'
        
        return health_status
```

### 日志分析
```python
# utils/log_analyzer.py
import re
import os
from datetime import datetime, timedelta
from collections import defaultdict, Counter

class LogAnalyzer:
    """日志分析工具"""
    
    def __init__(self, log_file_path):
        self.log_file_path = log_file_path
    
    def parse_log_line(self, line):
        """解析日志行"""
        # 日志格式：2024-01-01 12:00:00 INFO: message [in file:line]
        pattern = r'(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) (\w+): (.+?) \[in (.+?):(\d+)\]'
        match = re.match(pattern, line.strip())
        
        if match:
            return {
                'timestamp': datetime.strptime(match.group(1), '%Y-%m-%d %H:%M:%S'),
                'level': match.group(2),
                'message': match.group(3),
                'file': match.group(4),
                'line': int(match.group(5))
            }
        return None
    
    def analyze_logs(self, hours=24):
        """分析日志"""
        if not os.path.exists(self.log_file_path):
            return None
        
        start_time = datetime.now() - timedelta(hours=hours)
        
        stats = {
            'total_lines': 0,
            'by_level': Counter(),
            'by_hour': defaultdict(int),
            'errors': [],
            'warnings': [],
            'top_files': Counter(),
            'recent_activity': []
        }
        
        try:
            with open(self.log_file_path, 'r', encoding='utf-8') as f:
                for line in f:
                    stats['total_lines'] += 1
                    
                    parsed = self.parse_log_line(line)
                    if not parsed or parsed['timestamp'] < start_time:
                        continue
                    
                    # 按级别统计
                    stats['by_level'][parsed['level']] += 1
                    
                    # 按小时统计
                    hour_key = parsed['timestamp'].strftime('%Y-%m-%d %H:00')
                    stats['by_hour'][hour_key] += 1
                    
                    # 按文件统计
                    stats['top_files'][parsed['file']] += 1
                    
                    # 收集错误和警告
                    if parsed['level'] == 'ERROR':
                        stats['errors'].append({
                            'timestamp': parsed['timestamp'].isoformat(),
                            'message': parsed['message'],
                            'file': parsed['file'],
                            'line': parsed['line']
                        })
                    elif parsed['level'] == 'WARNING':
                        stats['warnings'].append({
                            'timestamp': parsed['timestamp'].isoformat(),
                            'message': parsed['message'],
                            'file': parsed['file'],
                            'line': parsed['line']
                        })
                    
                    # 最近活动
                    if len(stats['recent_activity']) < 100:
                        stats['recent_activity'].append({
                            'timestamp': parsed['timestamp'].isoformat(),
                            'level': parsed['level'],
                            'message': parsed['message'][:100]  # 截断长消息
                        })
            
            # 转换为普通字典
            stats['by_level'] = dict(stats['by_level'])
            stats['by_hour'] = dict(stats['by_hour'])
            stats['top_files'] = dict(stats['top_files'].most_common(10))
            
            # 限制错误和警告数量
            stats['errors'] = stats['errors'][-50:]  # 最近50个错误
            stats['warnings'] = stats['warnings'][-50:]  # 最近50个警告
            
            return stats
            
        except Exception as e:
            return {'error': f'日志分析失败：{str(e)}'}
    
    def get_error_patterns(self):
        """分析错误模式"""
        if not os.path.exists(self.log_file_path):
            return []
        
        error_messages = []
        
        try:
            with open(self.log_file_path, 'r', encoding='utf-8') as f:
                for line in f:
                    parsed = self.parse_log_line(line)
                    if parsed and parsed['level'] == 'ERROR':
                        error_messages.append(parsed['message'])
            
            # 分析错误模式
            error_counter = Counter(error_messages)
            patterns = []
            
            for message, count in error_counter.most_common(10):
                patterns.append({
                    'pattern': message,
                    'count': count,
                    'percentage': round(count / len(error_messages) * 100, 2) if error_messages else 0
                })
            
            return patterns
            
        except Exception as e:
            return [{'error': f'错误模式分析失败：{str(e)}'}]
```

### 监控控制器
```python
# controllers/monitor_controller.py
from flask import Blueprint, jsonify, render_template
from flask_login import login_required
from auth.decorators import admin_required
from utils.monitor import SystemMonitor
from utils.log_analyzer import LogAnalyzer
from flask import current_app
import os

monitor_bp = Blueprint('monitor', __name__, url_prefix='/monitor')

@monitor_bp.route('/')
@login_required
@admin_required
def dashboard():
    """监控仪表板"""
    return render_template('monitor/dashboard.html')

@monitor_bp.route('/api/system')
@login_required
@admin_required
def get_system_info():
    """获取系统信息API"""
    system_info = SystemMonitor.get_system_info()
    if system_info:
        return jsonify({'success': True, 'data': system_info})
    else:
        return jsonify({'success': False, 'message': '获取系统信息失败'}), 500

@monitor_bp.route('/api/database')
@login_required
@admin_required
def get_database_stats():
    """获取数据库统计API"""
    db_stats = SystemMonitor.get_database_stats()
    if db_stats:
        return jsonify({'success': True, 'data': db_stats})
    else:
        return jsonify({'success': False, 'message': '获取数据库统计失败'}), 500

@monitor_bp.route('/api/health')
def health_check():
    """健康检查API"""
    health_status = SystemMonitor.check_health()
    status_code = 200 if health_status['status'] == 'healthy' else 503
    return jsonify(health_status), status_code

@monitor_bp.route('/api/logs')
@login_required
@admin_required
def get_log_analysis():
    """获取日志分析API"""
    log_file = os.path.join(current_app.root_path, 'logs', 'student_management.log')
    analyzer = LogAnalyzer(log_file)
    
    hours = request.args.get('hours', 24, type=int)
    analysis = analyzer.analyze_logs(hours)
    
    if analysis and 'error' not in analysis:
        return jsonify({'success': True, 'data': analysis})
    else:
        return jsonify({'success': False, 'message': analysis.get('error', '日志分析失败')}), 500

@monitor_bp.route('/api/error-patterns')
@login_required
@admin_required
def get_error_patterns():
    """获取错误模式API"""
    log_file = os.path.join(current_app.root_path, 'logs', 'student_management.log')
    analyzer = LogAnalyzer(log_file)
    
    patterns = analyzer.get_error_patterns()
    return jsonify({'success': True, 'data': patterns})
```

## 7.5 代码质量与规范

### 代码规范配置
```python
# .flake8
[flake8]
max-line-length = 88
ignore = E203, E266, E501, W503
max-complexity = 10
exclude = 
    .git,
    __pycache__,
    migrations,
    venv,
    .venv
```

```yaml
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.4.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files
  
  - repo: https://github.com/psf/black
    rev: 22.10.0
    hooks:
      - id: black
        language_version: python3
  
  - repo: https://github.com/pycqa/flake8
    rev: 5.0.4
    hooks:
      - id: flake8
  
  - repo: https://github.com/pycqa/isort
    rev: 5.10.1
    hooks:
      - id: isort
        args: ["--profile", "black"]
```

### 代码质量检查脚本
```bash
#!/bin/bash
# scripts/quality_check.sh

echo "开始代码质量检查..."

# 代码格式化
echo "1. 代码格式化检查..."
black --check .
if [ $? -ne 0 ]; then
    echo "代码格式不符合规范，请运行 'black .' 进行格式化"
    exit 1
fi

# 导入排序
echo "2. 导入排序检查..."
isort --check-only .
if [ $? -ne 0 ]; then
    echo "导入排序不符合规范，请运行 'isort .' 进行修复"
    exit 1
fi

# 代码风格检查
echo "3. 代码风格检查..."
flake8 .
if [ $? -ne 0 ]; then
    echo "代码风格检查失败"
    exit 1
fi

# 类型检查
echo "4. 类型检查..."
mypy . --ignore-missing-imports
if [ $? -ne 0 ]; then
    echo "类型检查失败"
    exit 1
fi

# 安全检查
echo "5. 安全检查..."
bandit -r . -x tests/
if [ $? -ne 0 ]; then
    echo "安全检查发现问题"
    exit 1
fi

# 测试覆盖率
echo "6. 测试覆盖率检查..."
pytest --cov=. --cov-report=term-missing --cov-fail-under=80
if [ $? -ne 0 ]; then
    echo "测试覆盖率不足80%"
    exit 1
fi

echo "所有检查通过！"
```

### 性能分析工具
```python
# utils/profiler.py
import cProfile
import pstats
import io
from functools import wraps
from flask import request, current_app
import time

class PerformanceProfiler:
    """性能分析工具"""
    
    @staticmethod
    def profile_function(func):
        """函数性能分析装饰器"""
        @wraps(func)
        def wrapper(*args, **kwargs):
            if current_app.config.get('ENABLE_PROFILING', False):
                pr = cProfile.Profile()
                pr.enable()
                
                start_time = time.time()
                result = func(*args, **kwargs)
                end_time = time.time()
                
                pr.disable()
                
                # 生成性能报告
                s = io.StringIO()
                ps = pstats.Stats(pr, stream=s).sort_stats('cumulative')
                ps.print_stats(10)  # 显示前10个最耗时的函数
                
                current_app.logger.info(
                    f"函数 {func.__name__} 执行时间: {end_time - start_time:.4f}秒\n"
                    f"性能分析:\n{s.getvalue()}"
                )
                
                return result
            else:
                return func(*args, **kwargs)
        return wrapper
    
    @staticmethod
    def profile_request(app):
        """请求性能分析中间件"""
        @app.before_request
        def before_request():
            if app.config.get('ENABLE_PROFILING', False):
                request.start_time = time.time()
        
        @app.after_request
        def after_request(response):
            if app.config.get('ENABLE_PROFILING', False) and hasattr(request, 'start_time'):
                duration = time.time() - request.start_time
                
                # 记录慢请求
                if duration > 1.0:  # 超过1秒的请求
                    app.logger.warning(
                        f"慢请求: {request.method} {request.path} - {duration:.4f}秒"
                    )
            
            return response

# 使用示例
@PerformanceProfiler.profile_function
def complex_calculation():
    """复杂计算示例"""
    result = 0
    for i in range(1000000):
        result += i * i
    return result
```

### 代码文档生成
```python
# scripts/generate_docs.py
import os
import ast
import inspect
from typing import Dict, List, Any

class DocGenerator:
    """代码文档生成器"""
    
    def __init__(self, project_root: str):
        self.project_root = project_root
        self.docs = []
    
    def extract_docstring(self, node):
        """提取文档字符串"""
        if (isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)) and
            node.body and isinstance(node.body[0], ast.Expr) and
            isinstance(node.body[0].value, ast.Str)):
            return node.body[0].value.s
        return None
    
    def analyze_file(self, file_path: str):
        """分析Python文件"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            tree = ast.parse(content)
            file_info = {
                'file': file_path,
                'classes': [],
                'functions': [],
                'module_docstring': ast.get_docstring(tree)
            }
            
            for node in ast.walk(tree):
                if isinstance(node, ast.ClassDef):
                    class_info = {
                        'name': node.name,
                        'docstring': self.extract_docstring(node),
                        'methods': [],
                        'line': node.lineno
                    }
                    
                    for item in node.body:
                        if isinstance(item, ast.FunctionDef):
                            method_info = {
                                'name': item.name,
                                'docstring': self.extract_docstring(item),
                                'args': [arg.arg for arg in item.args.args],
                                'line': item.lineno
                            }
                            class_info['methods'].append(method_info)
                    
                    file_info['classes'].append(class_info)
                
                elif isinstance(node, ast.FunctionDef) and node.col_offset == 0:
                    function_info = {
                        'name': node.name,
                        'docstring': self.extract_docstring(node),
                        'args': [arg.arg for arg in node.args.args],
                        'line': node.lineno
                    }
                    file_info['functions'].append(function_info)
            
            return file_info
            
        except Exception as e:
            print(f"分析文件 {file_path} 失败: {e}")
            return None
    
    def generate_markdown(self, output_file: str):
        """生成Markdown文档"""
        # 遍历项目文件
        for root, dirs, files in os.walk(self.project_root):
            # 跳过特定目录
            dirs[:] = [d for d in dirs if d not in ['.git', '__pycache__', 'venv', '.venv', 'node_modules']]
            
            for file in files:
                if file.endswith('.py'):
                    file_path = os.path.join(root, file)
                    file_info = self.analyze_file(file_path)
                    if file_info:
                        self.docs.append(file_info)
        
        # 生成Markdown内容
        markdown_content = self._generate_markdown_content()
        
        # 写入文件
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(markdown_content)
        
        print(f"文档已生成: {output_file}")
    
    def _generate_markdown_content(self) -> str:
        """生成Markdown内容"""
        content = ["# 项目API文档\n"]
        
        for doc in self.docs:
            relative_path = os.path.relpath(doc['file'], self.project_root)
            content.append(f"## {relative_path}\n")
            
            if doc['module_docstring']:
                content.append(f"{doc['module_docstring']}\n")
            
            # 类文档
            for cls in doc['classes']:
                content.append(f"### 类: {cls['name']}\n")
                if cls['docstring']:
                    content.append(f"{cls['docstring']}\n")
                
                # 方法文档
                for method in cls['methods']:
                    content.append(f"#### {method['name']}({', '.join(method['args'])})\n")
                    if method['docstring']:
                        content.append(f"{method['docstring']}\n")
            
            # 函数文档
            for func in doc['functions']:
                content.append(f"### 函数: {func['name']}({', '.join(func['args'])})\n")
                if func['docstring']:
                    content.append(f"{func['docstring']}\n")
            
            content.append("---\n")
        
        return "\n".join(content)

# 使用示例
if __name__ == '__main__':
    generator = DocGenerator('.')
    generator.generate_markdown('docs/API文档.md')
```

### 最佳实践总结

#### 1. 项目结构最佳实践
```
student_management/
├── app.py                 # 应用入口
├── config.py             # 配置文件
├── requirements.txt      # 依赖管理
├── .env                  # 环境变量
├── .gitignore           # Git忽略文件
├── README.md            # 项目说明
├── models/              # 数据模型
│   ├── __init__.py
│   ├── student.py
│   └── user.py
├── controllers/         # 控制器
│   ├── __init__.py
│   ├── student_controller.py
│   └── auth_controller.py
├── templates/           # 模板文件
│   ├── base.html
│   ├── students/
│   └── auth/
├── static/             # 静态文件
│   ├── css/
│   ├── js/
│   └── images/
├── utils/              # 工具函数
│   ├── __init__.py
│   ├── file_handler.py
│   └── validators.py
├── tests/              # 测试文件
│   ├── __init__.py
│   ├── test_models.py
│   └── test_controllers.py
├── migrations/         # 数据库迁移
├── logs/              # 日志文件
├── uploads/           # 上传文件
└── docs/              # 文档
```

#### 2. 编码规范
- **命名规范**：使用有意义的变量名和函数名
- **注释规范**：为复杂逻辑添加注释
- **文档字符串**：为所有公共函数和类添加文档字符串
- **类型提示**：使用类型提示提高代码可读性
- **错误处理**：合理处理异常情况

#### 3. 安全最佳实践
- **输入验证**：验证所有用户输入
- **SQL注入防护**：使用ORM参数化查询
- **XSS防护**：对输出进行转义
- **CSRF防护**：使用CSRF令牌
- **密码安全**：使用强密码策略和哈希存储
- **会话管理**：安全的会话配置

#### 4. 性能优化
- **数据库优化**：合理使用索引和查询优化
- **缓存策略**：使用适当的缓存机制
- **静态文件**：使用CDN和压缩
- **分页处理**：大数据集使用分页
- **异步处理**：耗时操作使用异步处理

#### 5. 部署最佳实践
- **环境分离**：开发、测试、生产环境分离
- **配置管理**：使用环境变量管理配置
- **日志管理**：完善的日志记录和分析
- **监控告警**：系统监控和异常告警
- **备份策略**：定期数据备份

## 本章小结

在本章中，我们完成了：
- ✅ 用户认证和权限管理系统
- ✅ 文件上传和处理功能
- ✅ 数据导入导出功能
- ✅ 系统监控和日志分析
- ✅ 代码质量保证和规范
- ✅ 性能分析和优化工具
- ✅ 最佳实践总结

## 下一章预告

在第八章中，我们将学习项目总结与进阶方向，包括：
- 项目回顾和技术总结
- 常见问题和解决方案
- 进阶学习路径
- 相关技术栈扩展
- 实际项目应用建议

现在我们已经掌握了完整的功能扩展和最佳实践，接下来让我们总结整个项目并探索进阶方向！